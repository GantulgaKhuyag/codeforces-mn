Цаг унших
=========
Галзуу эрдэмтэн Майк удаан хатуу дискүүдийг ашигладаггүй. Түүний "хард драйв"-ын
сайжируулалт нь ганц бус $n$ ширхэг зэрэгцээгээр өгөгдлийг уншиж чадах ялгаатай
толгойноос бүтсэн байна.

Гаднаас нь ажих аваас Майкын "хард драйв" нь замуудын төгсгөлгүй массив болж байв.
Массивын замууд нь зүүнээс баруунтаа $1$-ээс эхлэсэн тоогоор дугаарлагдсан болно.
Анхны төлөвт $i$ дахь уншигдаж буй толгойн дээр $h_i$ замын дугаар байрлана.
Уншигдаж буй толгойнууд тус бүрд "хард драйв"-ын микропрограм зүүн болон баруун
талын ганц зам руу хөдлөх боломжтой, эсвэл одоо байгаа зам дээр орхидог.
Ажиллагааны явцад толгой бүрийн хөдөлгөөн нь өөрсдийн хамаатай дарааллаа өөрчилж
чадах бусад толгойн хөдөлгөөнтэй харшилдахгүй ба энд аль ч замуудын дээр олон
ширхэг уншигдаж буй толгой байх боломжтой. Хэрэв багадаа ганц ширхэг толгой
тухайн замаар явсан бол тухайн замыг уншсан гэж үзнэ. Тухайлбал
$h_1, h_2, ..., h_n$-аар дугаарлагдсан бүх зам ажиллагааны эхэнд уншигдсан.

![][1]

Майк $m$ ширхэг ялгаатай замууд болох $p_1, p_2, ..., p_m$ тоонуудыг унших
хэрэгтэй. Микропрограмын толгойг хөдөлгөж өгөгдсөн замуудыг бүгдийг нь уншихад
шаардагдах хамгийн бага хугацааг олно уу.  Мөн дурын бусад замууд уншигдсан байж болно.


### Оролт
Оролтын эхний мөрөнд дискний толгойн тоонууд болон унших ёстой замуудыг тоог
илэрхийлэх $n$, $m$ ($1 ≤ n, m ≤ 10^5$) тоонууд зайгаар тусгаарлагдан өгөгдөнө.
Хоёр дахь мөрөнд толгойн байрлалуудыг илэрхийлэх $n$ ширхэг ялгаатай тоо болох
$h_i$ ($1 ≤ h_i ≤ 10^{10}$, $h_i < h_i + 1$) өсөх дарааллаар өгөгдөнө.
Гурав дахь мөрөнд унших замуудын тоог илэрхийл $m$ ширхэг ялгаатай тоо болох
$p_i$ ($1 ≤ p_i ≤ 10^{10}$, $p_i < p_i + 1$) өсөх дарааллаар өгөгдөнө.

C++ хэл дээр 64-битийн тоо хэрэглэх үед %lld-г хэрэглэхгүй байхыг зөвлөж байна.
%I64d эсвэл cin, cout стриймийг ашиглана уу.


### Гаралт
Бүх хэрэгтэй замыг унших хамгийн бага хугацааг секундаар илэрхийлэх ганц тоог
хэвлэ.

  [1]: http://espresso.codeforces.com/79247149e8374d4c388dad17222308c98ad4ead5.png

-- Э.Шүрэнчулуун
